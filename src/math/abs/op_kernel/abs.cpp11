#include "kernel_operator.h"

#define ABS_TILING_0 1         //直接改变符号 :float16, bfp16
#define ABS_TILING_1 2         //int32
#define ABS_TILING_2 3         //int64
#define ABS_TILING_3 4         //complex64
#define ABS_TILING_4 5         //float32

constexpr int32_t BUFFER_NUM = 2; // tensor num for each queue
constexpr int32_t CALC_ALIGN_NUM =256;


/*
class KernelAbs {
public:
    __aicore__ inline KernelAbs() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, 
                                uint32_t bigDataCoreNum, uint32_t smallBlockLength, uint32_t bigBlockLength,
                                uint32_t smallTileNum, uint32_t smallTileLength, uint32_t smallLasttileLength,
                                uint32_t bigTileNum, uint32_t bigTileLength, uint32_t bigLasttileLength,
                                uint32_t dataWidth)
    {
        ASSERT(GetBlockNum() != 0 && "block dim can not be zero!");
    
        // AscendC::printf("this->times = %d \n", this->times);

        if(AscendC::GetBlockIdx() >= bigDataCoreNum)
        {
            xGm.SetGlobalBuffer((__gm__ uint16_t*)x + (bigDataCoreNum * bigBlockLength ) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength);
            yGm.SetGlobalBuffer((__gm__ uint16_t*)y + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, smallTileLength * sizeof(uint16_t));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, smallTileLength * sizeof(uint16_t));
            this->tileNum = smallTileNum;
            this->tileLength = smallTileLength;
            this->lasttileLength = smallLasttileLength;  
        }
        else
        {
            xGm.SetGlobalBuffer((__gm__ uint16_t*)x + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            yGm.SetGlobalBuffer((__gm__ uint16_t*)y + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, bigTileLength * sizeof(uint16_t));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, bigTileLength * sizeof(uint16_t));
            this->tileNum = bigTileNum;
            this->tileLength = bigTileLength;
            this->lasttileLength = bigLasttileLength;  
        }  

        
        pipe.InitBuffer(tempBuf, (CALC_ALIGN_NUM));
        this->tempLocal = tempBuf.Get<uint16_t>();
        if(dataWidth == 2) {
            AscendC::Duplicate(tempLocal, (uint16_t)(32767), 128);
        } 
        else if(dataWidth == 4) {
            AscendC::Duplicate(tempLocal, (uint16_t)(65535), 128);
            for (int i=1; i<128; i=i+2) {
                tempLocal.SetValue(i, (uint16_t)(32767));
            }
            // //AscendC::DumpTensor(tempLocal, 1001, 128);
        }
             
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum;
        this->calcLength = this->tileLength;
        this->repeat = ((this->tileLength + 127)/ (128)) ;
        for (int32_t i = 0; i < loopCount; i++) {
            if(i == loopCount -1)
            {
                this->calcLength = this->lasttileLength;
                this->repeat = (this->calcLength + 127)/ (128) ;
            }
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<uint16_t> xLocal = inQueueX.AllocTensor<uint16_t>();
        AscendC::DataCopy(xLocal, xGm[progress * this->tileLength], this->calcLength);
        inQueueX.EnQue(xLocal);
    }

    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<uint16_t> xLocal = inQueueX.DeQue<uint16_t>();
        AscendC::LocalTensor<uint16_t> yLocal = outQueueY.AllocTensor<uint16_t>();

        uint64_t mask = 128;

        AscendC::And(yLocal.ReinterpretCast<uint16_t>(), xLocal.ReinterpretCast<uint16_t>(), tempLocal, mask, (uint8_t)(this->repeat), { 1, 1, 1, 8, 8, 0 });
        // AscendC::printf("this->repeat = %d \n", (this->repeat));
        // //AscendC::DumpTensor(xLocal.ReinterpretCast<uint16_t>(), 2001, 128);
        // //AscendC::DumpTensor(tempLocal, 2002, 128);
        // //AscendC::DumpTensor(yLocal.ReinterpretCast<uint16_t>(), 2003, 128);

        outQueueY.EnQue<uint16_t>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }

    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<uint16_t> yLocal = outQueueY.DeQue<uint16_t>();
        AscendC::DataCopy(yGm[progress * this->tileLength], yLocal, this->calcLength);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::TBuf<AscendC::TPosition::VECCALC>  tempBuf;
    AscendC::GlobalTensor<uint16_t> xGm;
    AscendC::GlobalTensor<uint16_t> yGm;
    AscendC::LocalTensor<uint16_t> tempLocal;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t calcLength;
    uint32_t lasttileLength;
    uint32_t times;
    uint32_t repeat;
};
*/

class KernelAbs {
public:
    __aicore__ inline KernelAbs() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, 
                                uint32_t bigDataCoreNum, uint32_t smallBlockLength, uint32_t bigBlockLength,
                                uint32_t smallTileNum, uint32_t smallTileLength, uint32_t smallLasttileLength,
                                uint32_t bigTileNum, uint32_t bigTileLength, uint32_t bigLasttileLength,
                                uint32_t dataWidth)
    {
        ASSERT(GetBlockNum() != 0 && "block dim can not be zero!");
        
        // AscendC::printf("this->times = %d \n", this->times);
        
        if(AscendC::GetBlockIdx() >= bigDataCoreNum)
        {
            xGm.SetGlobalBuffer((__gm__ half*)x + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength* this->times);
            yGm.SetGlobalBuffer((__gm__ half*)y + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength * this->times);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, smallTileLength * sizeof(half));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, smallTileLength * sizeof(half));
            this->tileNum = smallTileNum;
            this->tileLength = smallTileLength;
            this->lasttileLength = smallLasttileLength;         
        }
        else
        {
            xGm.SetGlobalBuffer((__gm__ half*)x + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            yGm.SetGlobalBuffer((__gm__ half*)y + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, bigTileLength * sizeof(half));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, bigTileLength * sizeof(half));
            this->tileNum = bigTileNum;
            this->tileLength = bigTileLength;
            this->lasttileLength = bigLasttileLength;  
        }  

        
        // pipe.InitBuffer(tempBuf, (this->tileLength * sizeof(int32_t)));
        // this->tempLocal = tempBuf.Get<int32_t>();
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum;
        this->calcLength = this->tileLength;
        for (int32_t i = 0; i < loopCount; i++) {
            if(i == loopCount -1)
            {
                this->calcLength = this->lasttileLength;
            }
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<half> xLocal = inQueueX.AllocTensor<half>();
        AscendC::DataCopy(xLocal, xGm[progress * this->tileLength], this->calcLength);
        inQueueX.EnQue(xLocal);
    }

    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<half> xLocal = inQueueX.DeQue<half>();
        AscendC::LocalTensor<half> yLocal = outQueueY.AllocTensor<half>();
        
        AscendC::Abs(yLocal, xLocal, (this->calcLength));

        outQueueY.EnQue<half>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }

    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<half> yLocal = outQueueY.DeQue<half>();
        AscendC::DataCopy(yGm[progress * this->tileLength], yLocal, this->calcLength);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::TBuf<AscendC::TPosition::VECCALC>  tempBuf;
    AscendC::GlobalTensor<half> xGm;
    AscendC::GlobalTensor<half> yGm;
    AscendC::LocalTensor<half> tempLocal;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t calcLength;
    uint32_t lasttileLength;
    uint32_t times;
    uint32_t repeat;
};

class KernelAbs_int32 {
public:
    __aicore__ inline KernelAbs_int32() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, 
                                uint32_t bigDataCoreNum, uint32_t smallBlockLength, uint32_t bigBlockLength,
                                uint32_t smallTileNum, uint32_t smallTileLength, uint32_t smallLasttileLength,
                                uint32_t bigTileNum, uint32_t bigTileLength, uint32_t bigLasttileLength,
                                uint32_t dataWidth)
    {
        ASSERT(GetBlockNum() != 0 && "block dim can not be zero!");
        
        // AscendC::printf("this->times = %d \n", this->times);
        
        if(AscendC::GetBlockIdx() >= bigDataCoreNum)
        {
            xGm.SetGlobalBuffer((__gm__ int32_t*)x + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength* this->times);
            yGm.SetGlobalBuffer((__gm__ int32_t*)y + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength * this->times);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, smallTileLength * sizeof(int32_t));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, smallTileLength * sizeof(int32_t));
            this->tileNum = smallTileNum;
            this->tileLength = smallTileLength;
            this->lasttileLength = smallLasttileLength;         
        }
        else
        {
            xGm.SetGlobalBuffer((__gm__ int32_t*)x + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            yGm.SetGlobalBuffer((__gm__ int32_t*)y + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, bigTileLength * sizeof(int32_t));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, bigTileLength * sizeof(int32_t));
            this->tileNum = bigTileNum;
            this->tileLength = bigTileLength;
            this->lasttileLength = bigLasttileLength;  
        }  

        
        pipe.InitBuffer(tempBuf, (this->tileLength * sizeof(int32_t)));
        this->tempLocal = tempBuf.Get<int32_t>();
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum;
        this->calcLength = this->tileLength;
        for (int32_t i = 0; i < loopCount; i++) {
            if(i == loopCount -1)
            {
                this->calcLength = this->lasttileLength;
            }
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<int32_t> xLocal = inQueueX.AllocTensor<int32_t>();
        AscendC::DataCopy(xLocal, xGm[progress * this->tileLength], this->calcLength);
        inQueueX.EnQue(xLocal);
    }

    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<int32_t> xLocal = inQueueX.DeQue<int32_t>();
        AscendC::LocalTensor<int32_t> yLocal = outQueueY.AllocTensor<int32_t>();
        
        int32_t scalar = 32;
        AscendC::ShiftRight(tempLocal, xLocal, scalar, (this->calcLength));
        
        //AscendC::DumpTensor(xLocal, 1009, 16);
        //AscendC::DumpTensor(xLocal.ReinterpretCast<uint16_t>(), 1010, 16);
        //AscendC::DumpTensor(tempLocal.ReinterpretCast<uint16_t>(), 1001, 16);
    
        AscendC::Or(yLocal.ReinterpretCast<uint16_t>(), xLocal.ReinterpretCast<uint16_t>(), tempLocal.ReinterpretCast<uint16_t>(), (this->calcLength)*2);
        
        //AscendC::DumpTensor(yLocal.ReinterpretCast<uint16_t>(), 1002, 16);
        
        AscendC::And(xLocal.ReinterpretCast<uint16_t>(), xLocal.ReinterpretCast<uint16_t>(), tempLocal.ReinterpretCast<uint16_t>(), (this->calcLength)*2);
        
        //AscendC::DumpTensor(xLocal.ReinterpretCast<uint16_t>(), 1003, 16);
        
        AscendC::Not(xLocal.ReinterpretCast<uint16_t>(), xLocal.ReinterpretCast<uint16_t>(), (this->calcLength)*2);
        
        //AscendC::DumpTensor(xLocal.ReinterpretCast<uint16_t>(), 1004, 16);
        
        AscendC::And(yLocal.ReinterpretCast<uint16_t>(), yLocal.ReinterpretCast<uint16_t>(), xLocal.ReinterpretCast<uint16_t>(), (this->calcLength)*2);
        
        //AscendC::DumpTensor(yLocal.ReinterpretCast<uint16_t>(), 1005, 16);
        
        AscendC::Sub(yLocal.ReinterpretCast<int32_t>(), yLocal.ReinterpretCast<int32_t>(), tempLocal.ReinterpretCast<int32_t>(), (this->calcLength));
        
        //AscendC::DumpTensor(yLocal.ReinterpretCast<uint16_t>(), 1006, 16);
        //AscendC::DumpTensor(yLocal.ReinterpretCast<int32_t>(), 1007, 16);

//         uint64_t mask = 128;

//         AscendC::And(yLocal.ReinterpretCast<uint16_t>(), xLocal.ReinterpretCast<uint16_t>(), tempLocal, mask, (uint8_t)(this->repeat), { 1, 1, 1, 8, 8, 0 });
        
        // //AscendC::DumpTensor(xLocal.ReinterpretCast<uint16_t>(), 2001, 128);
        // //AscendC::DumpTensor(tempLocal, 2002, 128);
        // //AscendC::DumpTensor(yLocal.ReinterpretCast<uint16_t>(), 2003, 128);

        outQueueY.EnQue<int32_t>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }

    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<int32_t> yLocal = outQueueY.DeQue<int32_t>();
        AscendC::DataCopy(yGm[progress * this->tileLength], yLocal, this->calcLength);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::TBuf<AscendC::TPosition::VECCALC>  tempBuf;
    AscendC::GlobalTensor<int32_t> xGm;
    AscendC::GlobalTensor<int32_t> yGm;
    AscendC::LocalTensor<int32_t> tempLocal;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t calcLength;
    uint32_t lasttileLength;
    uint32_t times;
    uint32_t repeat;
};


class KernelAbs_int64 {
public:
    __aicore__ inline KernelAbs_int64() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, 
                                uint32_t bigDataCoreNum, uint32_t smallBlockLength, uint32_t bigBlockLength,
                                uint32_t smallTileNum, uint32_t smallTileLength, uint32_t smallLasttileLength,
                                uint32_t bigTileNum, uint32_t bigTileLength, uint32_t bigLasttileLength,
                                uint32_t dataWidth)
    {
        ASSERT(GetBlockNum() != 0 && "block dim can not be zero!");
        
        // AscendC::printf("this->times = %d \n", this->times);
        
        if(AscendC::GetBlockIdx() >= bigDataCoreNum)
        {
            xGm.SetGlobalBuffer((__gm__ int64_t*)x + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength* this->times);
            yGm.SetGlobalBuffer((__gm__ int64_t*)y + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength * this->times);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, smallTileLength * sizeof(int64_t));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, smallTileLength * sizeof(int64_t));
            this->tileNum = smallTileNum;
            this->tileLength = smallTileLength;
            this->lasttileLength = smallLasttileLength;         
        }
        else
        {
            xGm.SetGlobalBuffer((__gm__ int64_t*)x + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            yGm.SetGlobalBuffer((__gm__ int64_t*)y + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, bigTileLength * sizeof(int64_t));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, bigTileLength  * sizeof(int64_t));
            this->tileNum = bigTileNum;
            this->tileLength = bigTileLength;
            this->lasttileLength = bigLasttileLength;  
        }  

    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum;
        this->calcLength = this->tileLength;
        for (int32_t i = 0; i < loopCount; i++) {
            if(i == loopCount -1)
            {
                this->calcLength = this->lasttileLength;
            }
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<int64_t> xLocal = inQueueX.AllocTensor<int64_t>();
        AscendC::DataCopy(xLocal, xGm[progress * this->tileLength], this->calcLength);
        inQueueX.EnQue(xLocal);
    }

    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<int64_t> xLocal = inQueueX.DeQue<int64_t>();
        AscendC::LocalTensor<int64_t> yLocal = outQueueY.AllocTensor<int64_t>();
        
        int64_t temp, sign;
        for (int32_t i=0; i<(this->calcLength); i++) {
            temp = xLocal.GetValue(i);
            sign = temp >> 63;
            temp = (temp ^ sign) - sign;
            yLocal.SetValue(i, temp);
        }

        outQueueY.EnQue<int64_t>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }

    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<int64_t> yLocal = outQueueY.DeQue<int64_t>();
        AscendC::DataCopy(yGm[progress * this->tileLength], yLocal, this->calcLength);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::GlobalTensor<int64_t> xGm;
    AscendC::GlobalTensor<int64_t> yGm;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t calcLength;
    uint32_t lasttileLength;
    uint32_t times;
    uint32_t repeat;
};

class KernelAbs_complex64 {
public:
    __aicore__ inline KernelAbs_complex64() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, 
                                uint32_t bigDataCoreNum, uint32_t smallBlockLength, uint32_t bigBlockLength,
                                uint32_t smallTileNum, uint32_t smallTileLength, uint32_t smallLasttileLength,
                                uint32_t bigTileNum, uint32_t bigTileLength, uint32_t bigLasttileLength,
                                uint32_t dataWidth)
    {
        ASSERT(GetBlockNum() != 0 && "block dim can not be zero!");
        
        // AscendC::printf("this->times = %d \n", this->times);
        
        if(AscendC::GetBlockIdx() >= bigDataCoreNum)
        {
            xGm.SetGlobalBuffer((__gm__ float*)x + (bigDataCoreNum * bigBlockLength * 2) + (smallBlockLength *2 * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength* this->times);
            yGm.SetGlobalBuffer((__gm__ float*)y + (bigDataCoreNum * bigBlockLength * 2) + (smallBlockLength * 2 * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength * this->times);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, smallTileLength * 2 * sizeof(float));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, smallTileLength * 2 * sizeof(float));
            this->tileNum = smallTileNum;
            this->tileLength = smallTileLength;
            this->lasttileLength = smallLasttileLength;         
        }
        else
        {
            xGm.SetGlobalBuffer((__gm__ float*)x + bigBlockLength * 2 * AscendC::GetBlockIdx(), bigBlockLength* 2);
            yGm.SetGlobalBuffer((__gm__ float*)y + bigBlockLength * 2 * AscendC::GetBlockIdx(), bigBlockLength* 2);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, bigTileLength * 2 * sizeof(float));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, bigTileLength * 2 * sizeof(float));
            this->tileNum = bigTileNum;
            this->tileLength = bigTileLength;
            this->lasttileLength = bigLasttileLength;  
        }  
      
        pipe.InitBuffer(realBuf, (this->tileLength * 2 * sizeof(float)));
        pipe.InitBuffer(imagBuf, (this->tileLength * 2 * sizeof(float)));
        pipe.InitBuffer(srcOffsetBuf, (this->tileLength * 2 * sizeof(uint32_t)));
        this->realLocal = realBuf.Get<float>();
        this->imagLocal = imagBuf.Get<float>();
        this->srcOffsetLocal = srcOffsetBuf.Get<uint32_t>();
        
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum;
        this->calcLength = this->tileLength;
        for (int32_t i = 0; i < loopCount; i++) {
            if(i == loopCount -1)
            {
                this->calcLength = this->lasttileLength;
            }
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<float> xLocal = inQueueX.AllocTensor<float>();
        AscendC::DataCopy(xLocal, xGm[progress * this->tileLength * 2], this->calcLength * 2);
        inQueueX.EnQue(xLocal);
    }

    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<float> xLocal = inQueueX.DeQue<float>();
        AscendC::LocalTensor<float> yLocal = outQueueY.AllocTensor<float>();

        for (int32_t j = 0; j < (this->calcLength); j++) {
            srcOffsetLocal.SetValue(j, j*8);
            // imagOffsetLocal.SetValue(j, j*8 + 4);
        }

        AscendC::Gather(realLocal, xLocal, srcOffsetLocal, 0, (this->calcLength));
        AscendC::Gather(imagLocal, xLocal, srcOffsetLocal, 4, (this->calcLength));

        AscendC::Mul(realLocal, realLocal, realLocal, (this->calcLength));
        AscendC::Mul(imagLocal, imagLocal, imagLocal, (this->calcLength));
        AscendC::Add(realLocal, realLocal, imagLocal, (this->calcLength));
        AscendC::Sqrt(realLocal, realLocal, (this->calcLength));
        AscendC:Duplicate(yLocal, (float)(0.0), (this->calcLength) * 2);
        for (int32_t j = 0; j < (this->calcLength); j++) {
            yLocal.SetValue(j*2, realLocal.GetValue(j));
            // imagOffsetLocal.SetValue(j, j*8 + 4);
        }  
        outQueueY.EnQue<float>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }

    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<float> yLocal = outQueueY.DeQue<float>();
        AscendC::DataCopy(yGm[progress * this->tileLength * 2], yLocal, this->calcLength * 2);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::TBuf<AscendC::TPosition::VECCALC>  realBuf, imagBuf, srcOffsetBuf;
    AscendC::GlobalTensor<float> xGm;
    AscendC::GlobalTensor<float> yGm;
    AscendC::LocalTensor<float> realLocal, imagLocal;
    AscendC::LocalTensor<uint32_t> srcOffsetLocal;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t calcLength;
    uint32_t lasttileLength;
    uint32_t times;
    uint32_t repeat;
};


class KernelAbs_float {
public:
    __aicore__ inline KernelAbs_float() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, 
                                uint32_t bigDataCoreNum, uint32_t smallBlockLength, uint32_t bigBlockLength,
                                uint32_t smallTileNum, uint32_t smallTileLength, uint32_t smallLasttileLength,
                                uint32_t bigTileNum, uint32_t bigTileLength, uint32_t bigLasttileLength,
                                uint32_t dataWidth)
    {
        ASSERT(GetBlockNum() != 0 && "block dim can not be zero!");
        
        // AscendC::printf("this->times = %d \n", this->times);
        
        if(AscendC::GetBlockIdx() >= bigDataCoreNum)
        {
            xGm.SetGlobalBuffer((__gm__ float*)x + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength* this->times);
            yGm.SetGlobalBuffer((__gm__ float*)y + (bigDataCoreNum * bigBlockLength) + (smallBlockLength * (AscendC::GetBlockIdx() - bigDataCoreNum)), smallBlockLength * this->times);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, smallTileLength * sizeof(float));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, smallTileLength * sizeof(float));
            this->tileNum = smallTileNum;
            this->tileLength = smallTileLength;
            this->lasttileLength = smallLasttileLength;         
        }
        else
        {
            xGm.SetGlobalBuffer((__gm__ float*)x + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            yGm.SetGlobalBuffer((__gm__ float*)y + bigBlockLength * AscendC::GetBlockIdx(), bigBlockLength);
            pipe.InitBuffer(inQueueX, BUFFER_NUM, bigTileLength * sizeof(float));
            pipe.InitBuffer(outQueueY, BUFFER_NUM, bigTileLength * sizeof(float));
            this->tileNum = bigTileNum;
            this->tileLength = bigTileLength;
            this->lasttileLength = bigLasttileLength;  
        }  

        
        // pipe.InitBuffer(tempBuf, (this->tileLength * sizeof(int32_t)));
        // this->tempLocal = tempBuf.Get<int32_t>();
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum;
        this->calcLength = this->tileLength;
        for (int32_t i = 0; i < loopCount; i++) {
            if(i == loopCount -1)
            {
                this->calcLength = this->lasttileLength;
            }
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<float> xLocal = inQueueX.AllocTensor<float>();
        AscendC::DataCopy(xLocal, xGm[progress * this->tileLength], this->calcLength);
        inQueueX.EnQue(xLocal);
    }

    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<float> xLocal = inQueueX.DeQue<float>();
        AscendC::LocalTensor<float> yLocal = outQueueY.AllocTensor<float>();
        
        AscendC::Abs(yLocal, xLocal, (this->calcLength));

        outQueueY.EnQue<float>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }

    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<float> yLocal = outQueueY.DeQue<float>();
        AscendC::DataCopy(yGm[progress * this->tileLength], yLocal, this->calcLength);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::TBuf<AscendC::TPosition::VECCALC>  tempBuf;
    AscendC::GlobalTensor<float> xGm;
    AscendC::GlobalTensor<float> yGm;
    AscendC::LocalTensor<float> tempLocal;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t calcLength;
    uint32_t lasttileLength;
    uint32_t times;
    uint32_t repeat;
};

extern "C" __global__ __aicore__ void abs(GM_ADDR x, GM_ADDR y, GM_ADDR workspace, GM_ADDR tiling) {
    GET_TILING_DATA(tiling_data, tiling);
    // TODO: user kernel impl
    if (TILING_KEY_IS(ABS_TILING_0)) 
    {
        KernelAbs op;
        op.Init(x, y, 
                tiling_data.bigDataCoreNum, tiling_data.smallBlockLength, tiling_data.bigBlockLength,
                tiling_data.smallTileNum, tiling_data.smallTileLength, tiling_data.smallLasttileLength, 
                tiling_data.bigTileNum, tiling_data.bigTileLength, tiling_data.bigLasttileLength,
                tiling_data.dataWidth);
        op.Process();         
    }
    else if (TILING_KEY_IS(ABS_TILING_1)) 
    {
        KernelAbs_int32 op1;
        op1.Init(x, y, 
                tiling_data.bigDataCoreNum, tiling_data.smallBlockLength, tiling_data.bigBlockLength,
                tiling_data.smallTileNum, tiling_data.smallTileLength, tiling_data.smallLasttileLength, 
                tiling_data.bigTileNum, tiling_data.bigTileLength, tiling_data.bigLasttileLength,
                tiling_data.dataWidth);
        op1.Process();           
    }
    else if (TILING_KEY_IS(ABS_TILING_2)) 
    {
        KernelAbs_int64 op2;
        op2.Init(x, y, 
                tiling_data.bigDataCoreNum, tiling_data.smallBlockLength, tiling_data.bigBlockLength,
                tiling_data.smallTileNum, tiling_data.smallTileLength, tiling_data.smallLasttileLength, 
                tiling_data.bigTileNum, tiling_data.bigTileLength, tiling_data.bigLasttileLength,
                tiling_data.dataWidth);
        op2.Process();           
    }    
    
    else if (TILING_KEY_IS(ABS_TILING_3)) 
    {
        KernelAbs_complex64 op3;
        op3.Init(x, y, 
                tiling_data.bigDataCoreNum, tiling_data.smallBlockLength, tiling_data.bigBlockLength,
                tiling_data.smallTileNum, tiling_data.smallTileLength, tiling_data.smallLasttileLength, 
                tiling_data.bigTileNum, tiling_data.bigTileLength, tiling_data.bigLasttileLength,
                tiling_data.dataWidth);
        op3.Process();           
    }   
    else if (TILING_KEY_IS(ABS_TILING_4)) 
    {
        KernelAbs_float op4;
        op4.Init(x, y, 
                tiling_data.bigDataCoreNum, tiling_data.smallBlockLength, tiling_data.bigBlockLength,
                tiling_data.smallTileNum, tiling_data.smallTileLength, tiling_data.smallLasttileLength, 
                tiling_data.bigTileNum, tiling_data.bigTileLength, tiling_data.bigLasttileLength,
                tiling_data.dataWidth);
        op4.Process();           
    }     
}